#include <math.h>
#include <complex.h>

#include <ruby.h>

#include "numo/narray.h"

enum wave_types {
	OSC_SINE,
	OSC_COMPLEX_SINE,
	OSC_TRIANGLE,
	OSC_COMPLEX_TRIANGLE,
	OSC_SQUARE,
	OSC_COMPLEX_SQUARE,
	OSC_RAMP,
	OSC_COMPLEX_RAMP,
	OSC_GAUSS,
	OSC_PARABOLA,
};

enum filter_types {
	FILT_LOWPASS,
	FILT_HIGHPASS,
	FILT_BANDPASS,
	FILT_NOTCH,
	FILT_ALLPASS,
	FILT_PEAK,
	FILT_LOWSHELF,
	FILT_HIGHSHELF,
};

static ID sym_osc_sine;
static ID sym_osc_complex_sine;
static ID sym_osc_triangle;
static ID sym_osc_complex_triangle;
static ID sym_osc_square;
static ID sym_osc_complex_square;
static ID sym_osc_ramp;
static ID sym_osc_complex_ramp;
static ID sym_osc_gauss;
static ID sym_osc_parabola;

// Automatically generated lookup table of integrate(-2 * arctanh(e ^ (i * x)), x) from -1.5707963267948966 to 0.0
// Generated by experiments/lookup_table.rb from mb-math, then copied and modified from m
// experiments/lookup_table.rb "integrate(-2 * arctanh(e ^ (i * x)), x)" -1.5707963267948966 0.0 101
static double LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X[] = {
	1.83193118835444,
	1.83180781576262,
	1.83143766754058,
	1.83082065231093,
	1.82995661765263,
	1.82884534991252,
	1.82748657394065,
	1.82587995274862,
	1.82402508708989,
	1.82192151496077,
	1.81956871102062,
	1.81696608592935,
	1.81411298560028,
	1.81100869036592,
	1.80765241405416,
	1.80404330297178,
	1.80018043479205,
	1.79606281734296,
	1.79168938729175,
	1.78705900872171,
	1.78217047159617,
	1.77702249010453,
	1.77161370088461,
	1.76594266111487,
	1.76000784646978,
	1.75380764893088,
	1.74734037444516,
	1.74060424042216,
	1.73359737305989,
	1.72631780448907,
	1.71876346972417,
	1.71093220340876,
	1.70282173634125,
	1.69442969176628,
	1.6857535814152,
	1.67679080127773,
	1.66753862708531,
	1.65799420948445,
	1.64815456887655,
	1.63801658989825,
	1.6275770155137,
	1.61683244068744,
	1.60577930560301,
	1.59441388838922,
	1.58273229731148,
	1.57073046238141,
	1.55840412633249,
	1.54574883490386,
	1.53275992636771,
	1.51943252022827,
	1.5057615050118,
	1.49174152505741,
	1.47736696620736,
	1.46263194028281,
	1.44753026821644,
	1.43205546169654,
	1.41620070315761,
	1.39995882393024,
	1.38332228033666,
	1.36628312748775,
	1.34883299050186,
	1.33096303282328,
	1.31266392126902,
	1.2939257873736,
	1.27473818453185,
	1.25509004035606,
	1.23496960356404,
	1.21436438459343,
	1.19326108899162,
	1.17164554245173,
	1.14950260614655,
	1.12681608074222,
	1.10356859713828,
	1.07974149156128,
	1.05531466211154,
	1.03026640319184,
	1.0045732133883,
	0.978209571264714,
	0.951147672083024,
	0.923357116553767,
	0.894804540171926,
	0.865453168251795,
	0.835262277060074,
	0.804186534892375,
	0.772175187675088,
	0.739171040340956,
	0.705109165640325,
	0.669915242615786,
	0.633503381583527,
	0.595773220410311,
	0.55660595857116,
	0.515858793504701,
	0.473356862775726,
	0.42888111381683,
	0.382149146272707,
	0.332783047937946,
	0.280250838337874,
	0.223747088396741,
	0.161903864374734,
	0.0918401856348807,
	-8.50583000021389e-15
};

// Automatically generated lookup table of integrate(-2 * arctanh(e ^ (i * x)), x) from -0.1 to 0.0
// Generated by experiments/lookup_table.rb from mb-math, then copied and modified from mb-math to mb-sound
// experiments/lookup_table.rb "integrate(-2 * arctanh(e ^ (i * x)), x)" -0.1 0.0 21
static double SMALL_LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X[] = {
	0.399545439850515,
	0.384443605455943,
	0.369078095285853,
	0.353434288916255,
	0.337495840580432,
	0.321244354892652,
	0.304658975812297,
	0.287715857726498,
	0.270387473083062,
	0.252641688069872,
	0.234440500179617,
	0.215738267210309,
	0.196479142339785,
	0.176593212908555,
	0.155990402312772,
	0.134550231829575,
	0.112103181494428,
	0.0883926901258597,
	0.0629831458876054,
	0.0349573192633147,
	0
};

// Behaves like Ruby's % operator instead of fmod
// wraps X to be between 0 and Y
static double wrap(double x, double y)
{
	// this could instead be fmod(x, y) + y if x is negative
	return x - y * floor(x / y);
}

static ssize_t wrapsize(ssize_t x, ssize_t y)
{
	if (x >= 0 && x < y) {
		return x;
	}

	if (x < 0) {
		return x % y + y;
	}

	return x % y;
}

static double fetch_bounce(double table[], ssize_t len, ssize_t idx)
{
	if (idx >= 0 && idx < len) {
		return table[idx];
	}

	idx = wrapsize(idx, len * 2 - 2);

	if (idx >= len - 1) {
		idx = (2 * len - 2) - idx;
	}

	if (idx < 0 || idx >= len) {
		rb_raise(rb_eRuntimeError, "Bad index %zd", idx);
	}

	return table[idx];
}

// Handles expansion of quarter-wave lookup table (copied/modified from mb-math)
// Also see fetch_bounce from mb-math
static double get_lookup_i2aeixx(double table[], ssize_t len, ssize_t idx)
{
	double v = fetch_bounce(table, len, idx);

	if (idx >= len || idx <= -len) {
		v *= -1;
	}

	return v;
}

static double simple_catmull_rom(double p0, double p1, double p2, double p3, double blend)
{
	double t0 = 0.0;
	double t1 = 1.0;
	double t2 = 2.0;
	double t3 = 3.0;

	double d10 = t1 - t0;
	double d20 = t2 - t0;
	double d21 = t2 - t1;
	double d31 = t3 - t1;
	double d32 = t3 - t2;
	double t = blend * d21 + t1;
	double d0t = t0 - t;
	double d1t = t1 - t;
	double d2t = t2 - t;
	double d3t = t3 - t;

	double a1 = p0 * (d1t / d10) - p1 * (d0t / d10);
	double a2 = p1 * (d2t / d21) - p2 * (d1t / d21);
	double a3 = p2 * (d3t / d32) - p3 * (d2t / d32);
	double b1 = a1 * (d2t / d20) - a2 * (d0t / d20);
	double b2 = a2 * (d3t / d31) - a3 * (d1t / d31);

	return b1 * (d2t / d21) - b2 * (d1t / d21);
}

// Automatically generated (then manually modified) lookup-table-based
// approximation of integrate(-2 * arctanh(e ^ (i * x)), x)
// Uses 101 steps between -1.5707963267948966 and 0.0
// Generated by experiments/lookup_table.rb from mb-math with the help of Sage
static double complex lookup_integrate_2_arctanh_e_i_x_x(double x)
{
	double offset;
	double *table;
	size_t len;

	x = wrap(x + M_PI, 2.0 * M_PI) - M_PI;

	if (x > -0.09 && x < 0.09) {
		offset = (x + 0.1) * 20 / 0.1;
		table = SMALL_LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X;
		len = sizeof(SMALL_LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X) / sizeof(SMALL_LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X[0]);
	} else if (x > M_PI - 0.098) {
		offset = (x - M_PI + 0.1) * -20 / 0.1 + 40;
		table = SMALL_LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X;
		len = sizeof(SMALL_LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X) / sizeof(SMALL_LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X[0]);
	} else if (x < -M_PI + 0.098) {
		offset = (x + M_PI - 0.1) * -20 / 0.1;
		table = SMALL_LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X;
		len = sizeof(SMALL_LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X) / sizeof(SMALL_LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X[0]);
	} else {
		offset = (x + 1.5707963267948966) * 100 / 1.5707963267948966;
		table = LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X;
		len = sizeof(LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X) / sizeof(LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X[0]);
	}

	ssize_t idx = floor(offset);
	double frac = offset - idx;
	double real = simple_catmull_rom(
			get_lookup_i2aeixx(table, len, idx - 1),
			get_lookup_i2aeixx(table, len, idx),
			get_lookup_i2aeixx(table, len, idx + 1),
			get_lookup_i2aeixx(table, len, idx + 2),
			frac
			);

	// Triangle wave borrowed from mb-sound, back from mb-math
	double phi = wrap(x - M_PI_2, 2.0 * M_PI);
	double imag;
	if (phi < M_PI_2) {
		// Initial rise from 0..1 in 0..pi/2
		imag = phi * M_2_PI;
	} else if (phi < (1.5 * M_PI)) {
		// Fall from 1..-1 in pi/2..3pi/2
		imag = 2.0 - phi * M_2_PI;
	} else {
		// Final rise from -1..0 in 3pi/2..2pi
		imag = phi * M_2_PI - 4.0;
	}

	// 2.4674...*i == -pi*log(2) + I*dilog(2)
	return real - I * 2.46740110027234 * imag;
}

static double complex csc_int(double complex z)
{
	return -2.0 * conj(catanh(cexp(I * z))) + M_PI / (2.0 * I);
}

static double complex csc_int_int(double x)
{
	return lookup_integrate_2_arctanh_e_i_x_x(x);
}

static double complex cot_int(double complex z)
{
	return -M_2_PI * clog(cexp(I * z) + I) + I;
}

static double complex osc_sample(enum wave_types wave_type, double phi)
{
	double x;
	double complex z;
	double im;

	switch(wave_type) {
		case OSC_SINE:
			return sin(phi);

		case OSC_COMPLEX_SINE:
			return cexp(I * (phi - M_PI / 2));

		case OSC_TRIANGLE:
			if (phi < M_PI_2) {
				// Rise from 0..1 in 0..pi/2
				return phi * M_2_PI;
			} else if (phi < (M_PI + M_PI_2)) {
				// Fall from 1..-1 in pi/2..3pi/2
				return 2.0 - phi * M_2_PI;
			} else {
				// Rise from -1.0 in 3pi/2..2pi
				return phi * M_2_PI - 4.0;
			}

		case OSC_COMPLEX_TRIANGLE:
			// see lib/mb/sound/oscillator.rb
			// 2.4674...*i == -pi*log(2) + I*dilog(2)
			return csc_int_int(phi + M_PI_2) * I / 2.46740110027234;

		case OSC_SQUARE:
			// TODO: Normalize for RMS instead of peak?
			if (phi < M_PI) {
				return 1.0;
			} else {
				return -1.0;
			}

		case OSC_COMPLEX_SQUARE:
			z = 2.0 * conj(csc_int(phi)) * I / M_PI + 1.0;
			if (isinf(creal(z)) || isinf(cimag(z))) {
				z = 2.0 * conj(csc_int(phi + 0.0000001)) * I / M_PI + 1.0;
			}

			im = cimag(z);
			if (im > 3.8) {
				z = creal(z) + I * 3.8;
			} else if (im < -3.8) {
				z = creal(z) - I * 3.8;
			}

			return z;

		case OSC_RAMP:
			if (phi < M_PI) {
				// Initial rise from 0..1 in 0..pi
				return phi / M_PI;
			} else {
				// Final rise from -1..0 in pi..2pi
				return phi / M_PI - 2.0;
			}

		case OSC_COMPLEX_RAMP:
			z = cot_int(phi + M_PI_2) * I;

			im = cimag(z);
			if (im > 3.5) {
				z = creal(z) + I * 3.5;
			} else if (im < -3.5) {
				z = creal(z) - I * 3.5;
			}

			return z;

		case OSC_GAUSS:
			x = phi / M_PI;
			if (x < 1.0) {
				x = (sqrt(2.0 * log(1.6487212707 / (1.0 - x))) - 1) * 0.7071067811865476;
			} else {
				x = (1 - sqrt(2.0 * log(1.6487212707 / (x - 1.0)))) * 0.7071067811865476;
			}

			if (x < -3) {
				x = -3;
			} else if (x > 3) {
				x = 3;
			}

			return x;

		case OSC_PARABOLA:
			if (phi < M_PI) {
				x = 1.0 - phi * M_2_PI;
				return 1.0 - x * x;
			} else {
				x = phi * M_2_PI - 3.0;
				return x * x - 1.0;
			}

		default:
			return 0;
	}
}

static inline _Bool double_is_tiny(double v)
{
	return v < 1e-18 && v > -1e-18;
}

// Converted from lib/mb/sound/filter/biquad.rb
static double biquad_filter(
		double b0, double b1, double b2,
		double a1, double a2,
		double x0, double x1, double x2,
		double y1, double y2
		)
{
	double out = b0 * x0 + b1 * x1 + b2 * x2 - a1 * y1 - a2 * y2;

	// Prevent denormals
	if (double_is_tiny(out) && double_is_tiny(y1) && double_is_tiny(y2)) {
		out = 0;
	}

	return out;
}

static double complex biquad_complex(
		double complex b0, double complex b1, double complex b2,
		double complex a1, double complex a2,
		double complex x0, double complex x1, double complex x2,
		double complex y1, double complex y2
		)
{
	double complex out = b0 * x0 + b1 * x1 + b2 * x2 - a1 * y1 - a2 * y2;

	// Prevent denormals
	double real = creal(out);
	double imag = cimag(out);
	if (double_is_tiny(real) && double_is_tiny(creal(y1)) && double_is_tiny(creal(y2))) {
		real = 0;
	}
	if (double_is_tiny(imag) && double_is_tiny(cimag(y1)) && double_is_tiny(cimag(y2))) {
		imag = 0;
	}

	return real + I * imag;
}

static double smoothstep(double x)
{
	return 3*x*x - 2*x*x*x;
}

static double smootherstep(double x)
{
	return 6*x*x*x*x*x - 15*x*x*x*x + 10*x*x*x;
}

static double adsr(
		double time,
		double attack,
		double decay,
		double sustain,
		double release,
		double peak,
		_Bool on
		)
{
	double release_start = attack + decay;
	double total = attack + decay + release;

	double value;

	if (on) {
		if (time < 0) {
			value = 0.0;
		} else if (time < attack) {
			value = smoothstep(time / attack);
		} else if (time < release_start) {
			value = 1.0 - smoothstep((time - attack) / decay) * (1.0 - sustain);
		} else {
			value = sustain;
		}
	} else {
		if (time < release_start) {
			value = sustain;
		} else if (time < total) {
			value = (1.0 - smoothstep((time - release_start) / release)) * sustain;
		} else {
			value = 0.0;
		}
	}
	
#ifdef DEBUG
	fprintf(stderr, "Time=%.15f a=%.15f d=%.15f s=%.15f r=%.15f p=%.15f o=%d v=%.15f v*p=%.15f\n",
			time, attack, decay, sustain, release, peak, on, value, value * peak);
	fflush(stderr);
#endif

	return value * peak;
}

static enum wave_types find_wave_type(ID wave_type)
{
	if (wave_type == sym_osc_sine) {
		return OSC_SINE;
	}
	if (wave_type == sym_osc_complex_sine) {
		return OSC_COMPLEX_SINE;
	}
	if (wave_type == sym_osc_triangle) {
		return OSC_TRIANGLE;
	}
	if (wave_type == sym_osc_complex_triangle) {
		return OSC_COMPLEX_TRIANGLE;
	}
	if (wave_type == sym_osc_square) {
		return OSC_SQUARE;
	}
	if (wave_type == sym_osc_complex_square) {
		return OSC_COMPLEX_SQUARE;
	}
	if (wave_type == sym_osc_ramp) {
		return OSC_RAMP;
	}
	if (wave_type == sym_osc_complex_ramp) {
		return OSC_COMPLEX_RAMP;
	}
	if (wave_type == sym_osc_gauss) {
		return OSC_GAUSS;
	}
	if (wave_type == sym_osc_parabola) {
		return OSC_PARABOLA;
	}

	rb_raise(rb_eRuntimeError, "Invalid wave type given: %"PRIsVALUE, wave_type);
}

static complex double num_to_complex(VALUE z)
{
	double real, imag;

	if (!RB_TYPE_P(z, T_COMPLEX)) {
		real = NUM2DBL(z);
		imag = 0;
	} else {
		real = NUM2DBL(rb_complex_real(z));
		imag = NUM2DBL(rb_complex_imag(z));
	}

	return real + I * imag;
}

static VALUE complex_to_num(double complex z)
{
	return rb_dbl_complex_new(creal(z), cimag(z));
}

static VALUE ruby_csc_int(VALUE self, VALUE z)
{
	return complex_to_num(csc_int(num_to_complex(z)));
}

static VALUE ruby_csc_int_int(VALUE self, VALUE z)
{
	return complex_to_num(csc_int_int(num_to_complex(z)));
}

static VALUE ruby_cot_int(VALUE self, VALUE z)
{
	return complex_to_num(cot_int(num_to_complex(z)));
}

static VALUE ruby_smoothstep(VALUE self, VALUE x)
{
	return rb_float_new(smoothstep(NUM2DBL(x)));
}

static VALUE ruby_smootherstep(VALUE self, VALUE x)
{
	return rb_float_new(smootherstep(NUM2DBL(x)));
}

static VALUE ruby_fmod(VALUE self, VALUE x, VALUE y)
{
	return rb_float_new(fmod(NUM2DBL(x), NUM2DBL(y)));
}

static VALUE ruby_remainder(VALUE self, VALUE x, VALUE y)
{
	return rb_float_new(remainder(NUM2DBL(x), NUM2DBL(y)));
}

static VALUE ruby_wrap(VALUE self, VALUE x, VALUE y)
{
	return rb_float_new(wrap(NUM2DBL(x), NUM2DBL(y)));
}

static VALUE ruby_wrapsize(VALUE self, VALUE x, VALUE y)
{
	return SSIZET2NUM(wrapsize(NUM2SSIZET(x), NUM2SSIZET(y)));
}

static VALUE ruby_idiv(VALUE self, VALUE x, VALUE y)
{
	return SSIZET2NUM(NUM2SSIZET(x) / NUM2SSIZET(y));
}

static VALUE ruby_fdiv(VALUE self, VALUE x, VALUE y)
{
	return rb_float_new(NUM2DBL(x) / NUM2DBL(y));
}

static VALUE ruby_imod(VALUE self, VALUE x, VALUE y)
{
	return SSIZET2NUM(NUM2SSIZET(x) % NUM2SSIZET(y));
}

// Splits complex into real and imaginary
static VALUE ruby_complex(VALUE self, VALUE z)
{
	double complex c = num_to_complex(z);

	return rb_ary_new_from_args(2, rb_float_new(creal(c)), rb_float_new(cimag(c)));
}

static VALUE ruby_osc(VALUE self, VALUE wave_type, VALUE phi)
{
	enum wave_types wt = find_wave_type(SYM2ID(wave_type));

	double complex result = osc_sample(wt, NUM2DBL(phi));

	switch(wt) {
		case OSC_SINE:
		case OSC_SQUARE:
		case OSC_TRIANGLE:
		case OSC_RAMP:
		case OSC_GAUSS:
		case OSC_PARABOLA:
			return rb_float_new(creal(result));

		default:
			return rb_dbl_complex_new(creal(result), cimag(result));
	}
}

static VALUE ruby_biquad(VALUE self, VALUE b0, VALUE b1, VALUE b2, VALUE a1, VALUE a2, VALUE x0, VALUE x1, VALUE x2, VALUE y1, VALUE y2)
{
	double result = biquad_filter(
			NUM2DBL(b0), NUM2DBL(b1), NUM2DBL(b2),
			NUM2DBL(a1), NUM2DBL(a2),
			NUM2DBL(x0), NUM2DBL(x1), NUM2DBL(x2),
			NUM2DBL(y1), NUM2DBL(y2)
			);

	return rb_float_new(result);
}

static VALUE ruby_biquad_complex(VALUE self, VALUE b0, VALUE b1, VALUE b2, VALUE a1, VALUE a2, VALUE x0, VALUE x1, VALUE x2, VALUE y1, VALUE y2)
{
	double complex result = biquad_complex(
			num_to_complex(b0), num_to_complex(b1), num_to_complex(b2),
			num_to_complex(a1), num_to_complex(a2),
			num_to_complex(x0), num_to_complex(x1), num_to_complex(x2),
			num_to_complex(y1), num_to_complex(y2)
			);

	return complex_to_num(result);
}

static VALUE ruby_narray_to_array(VALUE self, VALUE narray)
{
	narray = rb_funcall(numo_cDComplex, rb_intern("cast"), 1, narray);
	size_t length = RNARRAY_SHAPE(narray)[0];
	VALUE out = rb_ary_new_capa(length);

	rb_warn("Size is %zu, ndim is %d, length is %zu\n", RNARRAY_SIZE(narray), RNARRAY_NDIM(narray), length);

	double complex *ptr = (double complex *)nary_get_pointer_for_read(narray);
	for(size_t i = 0; i < length; i++) {
		rb_ary_store(out, i, complex_to_num(ptr[i]));
	}

	return out;
}

#define BIQUAD_LOOP(buf_type, coeff_type, conv_from_rb, conv_to_rb, filter_func) do { \
	buf_type *data = (buf_type *)nary_get_pointer_for_read_write(buf); \
\
	coeff_type x0 = 0; \
	coeff_type x1 = conv_from_rb(rb_ary_entry(state, 1)); \
	coeff_type x2 = conv_from_rb(rb_ary_entry(state, 2)); \
	coeff_type y0 = 0; \
	coeff_type y1 = conv_from_rb(rb_ary_entry(state, 3)); \
	coeff_type y2 = conv_from_rb(rb_ary_entry(state, 4)); \
\
	coeff_type b0 = conv_from_rb(rb0); \
	coeff_type b1 = conv_from_rb(rb1); \
	coeff_type b2 = conv_from_rb(rb2); \
	coeff_type a1 = conv_from_rb(ra0); \
	coeff_type a2 = conv_from_rb(ra1); \
\
	for (size_t i = 0; i < length; i++) { \
		x0 = data[i]; \
		y0 = filter_func(b0, b1, b2, a1, a2, x0, x1, x2, y1, y2); \
		data[i] = y0; \
		y2 = y1; \
		y1 = y0; \
		x2 = x1; \
		x1 = x0; \
	} \
\
	rb_ary_store(state, 1, conv_to_rb(x1)); \
	rb_ary_store(state, 2, conv_to_rb(x2)); \
	rb_ary_store(state, 3, conv_to_rb(y1)); \
	rb_ary_store(state, 4, conv_to_rb(y2)); \
} while(0);

/*
 * Converted from lib/mb/sound/filter/biquad.rb
 *
 * buf must be a 1D Numo::DFloat or Numo::DComplex or compatible
 * state contains [buf, x1, x2, y1, y2]
 *
 * state will be mutated, and buf (state[0]) might be a different object!
 *
 * returns state
 */
static VALUE ruby_biquad_narray(VALUE self, VALUE rb0, VALUE rb1, VALUE rb2, VALUE ra0, VALUE ra1, VALUE state)
{
	VALUE buf, buf_type;

	Check_Type(state, T_ARRAY);

	buf = rb_ary_entry(state, 0);

	// References used for narray and Ruby APIs:
	// https://github.com/yoshoku/numo-pocketfft/blob/1ab489b165d4cde06b6d3a443ed9bfbc8e5c69d0/ext/numo/pocketfft/pocketfftext.c
	// https://github.com/ruby-numo/numo-narray/blob/6f5c91250c0cb948f6b811385d384c3f15af4dcd/ext/numo/narray/numo/intern.h
	// https://silverhammermba.github.io/emberb/c/
	// https://github.com/ruby/ruby/blob/master/doc/extension.rdoc
	
	// First try NArray's automatic conversion, to get e.g. from an array
	// of complex to DComplex
	buf_type = CLASS_OF(buf);
	if (buf_type != numo_cDComplex && buf_type != numo_cSComplex && buf_type != numo_cSFloat && buf_type != numo_cDFloat) {
		buf = rb_funcall(numo_cNArray, rb_intern("cast"), 1, buf);
		buf_type = CLASS_OF(buf);
	}

	// If that's still not a float or complex type, force conversion to float
	buf_type = CLASS_OF(buf);
	if (buf_type != numo_cDComplex && buf_type != numo_cSComplex && buf_type != numo_cSFloat && buf_type != numo_cDFloat) {
		buf = rb_funcall(numo_cDFloat, rb_intern("cast"), 1, buf);
		buf_type = CLASS_OF(buf);
	}

	int dim = RNARRAY_NDIM(buf);
	if (dim != 1) {
		rb_raise(rb_eArgError, "Only 1D NArrays may be processed (got %d dimensions)", dim);
	}

	_Bool was_inplace = !!TEST_INPLACE(buf);

	if (!RTEST(nary_check_contiguous(buf)) || !was_inplace) {
		buf = nary_dup(buf);
		SET_INPLACE(buf);
		was_inplace = 0;
	}

	size_t length = RNARRAY_SHAPE(buf)[0];

	if (buf_type == numo_cSFloat) {
		BIQUAD_LOOP(float, double, NUM2DBL, DBL2NUM, biquad_filter);
	} else if (buf_type == numo_cDFloat) {
		BIQUAD_LOOP(double, double, NUM2DBL, DBL2NUM, biquad_filter);
	} else if (buf_type == numo_cSComplex) {
		BIQUAD_LOOP(float complex, double complex, num_to_complex, complex_to_num, biquad_complex);
	} else if (buf_type == numo_cDComplex) {
		BIQUAD_LOOP(double complex, double complex, num_to_complex, complex_to_num, biquad_complex);
	} else {
		rb_raise(rb_eException, "BUG: Buffer was not SFloat, DFloat, SComplex, or DComplex");
	}

	if (!was_inplace) {
		UNSET_INPLACE(buf);
	}

	rb_ary_store(state, 0, buf);

	RB_GC_GUARD(buf);
	RB_GC_GUARD(state);

	return state;
}

/*
 * Generates cookbook filter biquad parameters, from lib/mb/sound/filter/cookbook.rb.
 *
 * Returns [omega, b0, b1, b2, a1, a2].
 */
static VALUE ruby_cookbook(VALUE self, VALUE type_id, VALUE f_samp, VALUE f_center, VALUE db_gain, VALUE quality, VALUE bandwidth_oct, VALUE shelf_slope)
{
	double amp = 0;
	if (RTEST(db_gain)) {
		amp = pow(10.0, NUM2DBL(db_gain) / 40.0);
	}

	double omega = 2.0 * M_PI * NUM2DBL(f_center) / NUM2DBL(f_samp);
	double cosine = cos(omega); // real part
	double sine = sin(omega); // imaginary part

	double alpha;
	if (RTEST(quality)) {
		alpha = sine / (2.0 * NUM2DBL(quality));
	} else if (RTEST(bandwidth_oct)) {
		alpha = sine * sinh(M_LN2 / 2.0 * NUM2DBL(bandwidth_oct) * omega / sine);
	} else if (RTEST(shelf_slope)) {
		alpha = sine * 0.5 * sqrt((amp + 1.0 / amp) * (1.0 / NUM2DBL(shelf_slope) - 1) + 2);
	} else {
		rb_raise(rb_eArgError, "Missing quality/bandwidth_oct/shelf_slope");
	}

	double a0_inv, a1, a2, b0, b1, b2;
	enum filter_types ftype = NUM2INT(type_id);
	switch(ftype) {
		case FILT_LOWPASS:
			a0_inv = 1.0 / (1.0 + alpha);
			a1 = -2.0 * cosine * a0_inv;
			a2 = (1.0 - alpha) * a0_inv;
			b0 = 0.5 * (1.0 - cosine) * a0_inv;
			b1 = (1.0 - cosine) * a0_inv;
			b2 = 0.5 * (1.0 - cosine) * a0_inv;
			break;

		case FILT_HIGHPASS:
			a0_inv = 1.0 / (1.0 + alpha);
			a1 = -2.0 * cosine * a0_inv;
			a2 = (1.0 - alpha) * a0_inv;
			b0 = 0.5 * (1.0 + cosine) * a0_inv;
			b1 = -(1.0 + cosine) * a0_inv;
			b2 = 0.5 * (1.0 + cosine) * a0_inv;
			break;

		case FILT_BANDPASS:
			a0_inv = 1.0 / (1.0 + alpha);
			a1 = -2.0 * cosine * a0_inv;
			a2 = (1.0 - alpha) * a0_inv;
			b0 = alpha * a0_inv;
			b1 = 0;
			b2 = -alpha * a0_inv;
			break;

		case FILT_NOTCH:
			a0_inv = 1.0 / (1.0 + alpha);
			a1 = -2.0 * cosine * a0_inv;
			a2 = (1.0 - alpha) * a0_inv;
			b0 = a0_inv;
			b1 = -2.0 * cosine * a0_inv;
			b2 = a0_inv;
			break;

		case FILT_ALLPASS:
			a0_inv = 1.0 / (1.0 + alpha);
			a1 = -2.0 * cosine * a0_inv;
			a2 = (1.0 - alpha) * a0_inv;
			b0 = (1.0 - alpha) * a0_inv;
			b1 = -2.0 * cosine * a0_inv;
			b2 = (1.0 + alpha) * a0_inv;
			break;

		case FILT_PEAK:
			if (!RTEST(db_gain)) {
				rb_raise(rb_eArgError, "Missing db_gain");
			}

			a0_inv = 1.0 / (1.0 + alpha / amp);
			a1 = -2.0 * cosine * a0_inv;
			a2 = (1.0 - alpha / amp) * a0_inv;
			b0 = (1.0 + alpha * amp) * a0_inv;
			b1 = -2.0 * cosine * a0_inv;
			b2 = (1.0 - alpha * amp) * a0_inv;
			break;

		case FILT_LOWSHELF:
			if (!RTEST(db_gain)) {
				rb_raise(rb_eArgError, "Missing db_gain");
			} else {
				double ap1 = amp + 1;
				double am1 = amp - 1;
				double asq2al = 2.0 * sqrt(amp) * alpha;

				a0_inv = 1.0 / (ap1 + am1 * cosine + asq2al);
				a1 = -2.0 * (am1 + ap1 * cosine) * a0_inv;
				a2 = (ap1 + am1 * cosine - asq2al) * a0_inv;
				b0 = amp * (ap1 - am1 * cosine + asq2al) * a0_inv;
				b1 = 2.0 * amp * (am1 - ap1 * cosine) * a0_inv;
				b2 = amp * (ap1 - am1 * cosine - asq2al) * a0_inv;
			}

			break;

		case FILT_HIGHSHELF:
			if (!RTEST(db_gain)) {
				rb_raise(rb_eArgError, "Missing db_gain");
			} else {
				double ap1 = amp + 1;
				double am1 = amp - 1;
				double asq2al = 2.0 * sqrt(amp) * alpha;

				a0_inv = 1.0 / (ap1 - am1 * cosine + asq2al);
				a1 = 2.0 * (am1 - ap1 * cosine) * a0_inv;
				a2 = (ap1 - am1 * cosine - asq2al) * a0_inv;
				b0 = amp * (ap1 + am1 * cosine + asq2al) * a0_inv;
				b1 = -2.0 * amp * (am1 + ap1 * cosine) * a0_inv;
				b2 = amp * (ap1 + am1 * cosine - asq2al) * a0_inv;
			}

			break;

		default:
			rb_raise(rb_eArgError, "Invalid filter type ID %"PRIsVALUE, type_id);
	}

	VALUE out = rb_ary_new_capa(6);
	rb_ary_store(out, 0, rb_float_new(omega));
	rb_ary_store(out, 1, rb_float_new(b0));
	rb_ary_store(out, 2, rb_float_new(b1));
	rb_ary_store(out, 3, rb_float_new(b2));
	rb_ary_store(out, 4, rb_float_new(a1));
	rb_ary_store(out, 5, rb_float_new(a2));

	return out;
}

VALUE ruby_adsr(VALUE self, VALUE time, VALUE attack, VALUE decay, VALUE sustain, VALUE release, VALUE peak, VALUE on)
{
	return rb_float_new(adsr(
				NUM2DBL(time),
				NUM2DBL(attack),
				NUM2DBL(decay),
				NUM2DBL(sustain),
				NUM2DBL(release),
				NUM2DBL(peak),
				RTEST(on)
				));
}

VALUE ruby_adsr_narray(VALUE self, VALUE narray, VALUE frame, VALUE rate, VALUE attack, VALUE decay, VALUE sustain, VALUE release, VALUE peak, VALUE on)
{
	if (CLASS_OF(narray) != numo_cDFloat && CLASS_OF(narray) != numo_cSFloat) {
		narray = rb_funcall(numo_cDFloat, rb_intern("cast"), 1, narray);
	}

	int dim = RNARRAY_NDIM(narray);
	if (dim != 1) {
		rb_raise(rb_eArgError, "Only 1D NArrays may be processed (got %d dimensions)", dim);
	}

	_Bool was_inplace = !!TEST_INPLACE(narray);

	if (!RTEST(nary_check_contiguous(narray)) || !was_inplace) {
		narray = nary_dup(narray);
		SET_INPLACE(narray);
		was_inplace = 0;
	}

	size_t length = RNARRAY_SHAPE(narray)[0];

	ssize_t current_frame = NUM2SSIZET(frame);
	double sample_rate = NUM2DBL(rate);
	double a = NUM2DBL(attack);
	double d = NUM2DBL(decay);
	double s = NUM2DBL(sustain);
	double r = NUM2DBL(release);
	double p = NUM2DBL(peak);
	_Bool o = RTEST(on);

	if (CLASS_OF(narray) == numo_cSFloat) {
		float *data = (float *)nary_get_pointer_for_write(narray);

		for(size_t i = 0; i < length; i++) {
			double t = current_frame / sample_rate;
#ifdef DEBUG
			fprintf(stderr, "CFrame=%zd, rate=%.15f, t=%.15f ", current_frame, sample_rate, t);
			fflush(stderr);
#endif
			data[i] = adsr(t, a, d, s, r, p, o);

			VALUE adsr_debug = rb_gv_get("$adsr_debug");
			if (RB_TYPE_P(adsr_debug, T_ARRAY)) { // XXX
				VALUE dbg_arr = rb_ary_new_from_args(
						11,
						rb_id2sym(rb_intern("cS")),
						SSIZET2NUM(current_frame),
						DBL2NUM(sample_rate),
						DBL2NUM(t),
						DBL2NUM(a),
						DBL2NUM(d),
						DBL2NUM(s),
						DBL2NUM(r),
						DBL2NUM(p),
						o ? Qtrue : Qfalse,
						DBL2NUM(data[i])
						);
				rb_ary_push(adsr_debug, dbg_arr);
			}

			current_frame += 1;
		}
	} else if (CLASS_OF(narray) == numo_cDFloat) {
		double *data = (double *)nary_get_pointer_for_write(narray);

		for(size_t i = 0; i < length; i++) {
			double t = current_frame / sample_rate;
#ifdef DEBUG
			fprintf(stderr, "CFrame=%zd, rate=%.15f, t=%.15f ", current_frame, sample_rate, t);
			fflush(stderr);
#endif
			data[i] = adsr(t, a, d, s, r, p, o);

			VALUE adsr_debug = rb_gv_get("$adsr_debug");
			if (RB_TYPE_P(adsr_debug, T_ARRAY)) { // XXX
				VALUE dbg_arr = rb_ary_new_from_args(
						11,
						rb_id2sym(rb_intern("cD")),
						SSIZET2NUM(current_frame),
						DBL2NUM(sample_rate),
						DBL2NUM(t),
						DBL2NUM(a),
						DBL2NUM(d),
						DBL2NUM(s),
						DBL2NUM(r),
						DBL2NUM(p),
						o ? Qtrue : Qfalse,
						DBL2NUM(data[i])
						);
				rb_ary_push(adsr_debug, dbg_arr);
			}

			current_frame += 1;
		}
	}

	RB_GC_GUARD(narray);

	return narray;
}

void Init_fast_sound(void)
{
	VALUE mb = rb_define_module("MB");
	VALUE fast_sound = rb_define_module_under(mb, "FastSound");

	sym_osc_sine = rb_intern("sine");
	sym_osc_complex_sine = rb_intern("complex_sine");
	sym_osc_triangle = rb_intern("triangle");
	sym_osc_complex_triangle = rb_intern("complex_triangle");
	sym_osc_square = rb_intern("square");
	sym_osc_complex_square = rb_intern("complex_square");
	sym_osc_ramp = rb_intern("ramp");
	sym_osc_complex_ramp = rb_intern("complex_ramp");
	sym_osc_gauss = rb_intern("gauss");
	sym_osc_parabola = rb_intern("parabola");

	// Oscillator functions
	rb_define_module_function(fast_sound, "osc", ruby_osc, 2);

	// Filtering functions
	rb_define_module_function(fast_sound, "biquad", ruby_biquad, 10);
	rb_define_module_function(fast_sound, "biquad_complex", ruby_biquad_complex, 10);
	rb_define_module_function(fast_sound, "biquad_narray", ruby_biquad_narray, 6);
	rb_define_module_function(fast_sound, "cookbook", ruby_cookbook, 7);

	// Envelope functions
	rb_define_module_function(fast_sound, "adsr", ruby_adsr, 7);
	rb_define_module_function(fast_sound, "adsr_narray", ruby_adsr_narray, 9);

	// Faster implementations of functions from mb-math
	rb_define_module_function(fast_sound, "cot_int", ruby_cot_int, 1);
	rb_define_module_function(fast_sound, "csc_int", ruby_csc_int, 1);
	rb_define_module_function(fast_sound, "csc_int_int", ruby_csc_int_int, 1);

	rb_define_module_function(fast_sound, "smoothstep", ruby_smoothstep, 1);
	rb_define_module_function(fast_sound, "smootherstep", ruby_smootherstep, 1);

	// Functions used when comparing C and Ruby's behavior for integer
	// division (C rounds to zero, Ruby rounds downward) and modulus (-1 %
	// 3 in Ruby is 2, in C it's -1)
	rb_define_module_function(fast_sound, "fmod", ruby_fmod, 2);
	rb_define_module_function(fast_sound, "remainder", ruby_remainder, 2);
	rb_define_module_function(fast_sound, "wrap", ruby_wrap, 2);
	rb_define_module_function(fast_sound, "wrapsize", ruby_wrapsize, 2);
	rb_define_module_function(fast_sound, "idiv", ruby_idiv, 2);
	rb_define_module_function(fast_sound, "fdiv", ruby_fdiv, 2);
	rb_define_module_function(fast_sound, "imod", ruby_imod, 2);

	// Functions to test conversion to and from Ruby complex datatypes
	rb_define_module_function(fast_sound, "complex", ruby_complex, 1);
	rb_define_module_function(fast_sound, "narray_to_array", ruby_narray_to_array, 1);
}
