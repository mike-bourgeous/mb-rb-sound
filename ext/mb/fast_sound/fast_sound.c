#include <math.h>
#include <complex.h>

#include <ruby.h>

#include "numo/narray.h"

enum wave_types {
	OSC_SINE,
	OSC_COMPLEX_SINE,
	OSC_TRIANGLE,
	OSC_COMPLEX_TRIANGLE,
	OSC_SQUARE,
	OSC_COMPLEX_SQUARE,
	OSC_RAMP,
	OSC_COMPLEX_RAMP,
	OSC_GAUSS,
	OSC_PARABOLA,
};

static ID sym_osc_sine;
static ID sym_osc_complex_sine;
static ID sym_osc_triangle;
static ID sym_osc_complex_triangle;
static ID sym_osc_square;
static ID sym_osc_complex_square;
static ID sym_osc_ramp;
static ID sym_osc_complex_ramp;
static ID sym_osc_gauss;
static ID sym_osc_parabola;

// Automatically generated lookup table of integrate(-2 * arctanh(e ^ (i * x)), x) from -1.5707963267948966 to 0.0
// Generated by experiments/lookup_table.rb from mb-math, then copied and modified from m
// experiments/lookup_table.rb "integrate(-2 * arctanh(e ^ (i * x)), x)" -1.5707963267948966 0.0 101
static double LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X[] = {
	1.83193118835444,
	1.83180781576262,
	1.83143766754058,
	1.83082065231093,
	1.82995661765263,
	1.82884534991252,
	1.82748657394065,
	1.82587995274862,
	1.82402508708989,
	1.82192151496077,
	1.81956871102062,
	1.81696608592935,
	1.81411298560028,
	1.81100869036592,
	1.80765241405416,
	1.80404330297178,
	1.80018043479205,
	1.79606281734296,
	1.79168938729175,
	1.78705900872171,
	1.78217047159617,
	1.77702249010453,
	1.77161370088461,
	1.76594266111487,
	1.76000784646978,
	1.75380764893088,
	1.74734037444516,
	1.74060424042216,
	1.73359737305989,
	1.72631780448907,
	1.71876346972417,
	1.71093220340876,
	1.70282173634125,
	1.69442969176628,
	1.6857535814152,
	1.67679080127773,
	1.66753862708531,
	1.65799420948445,
	1.64815456887655,
	1.63801658989825,
	1.6275770155137,
	1.61683244068744,
	1.60577930560301,
	1.59441388838922,
	1.58273229731148,
	1.57073046238141,
	1.55840412633249,
	1.54574883490386,
	1.53275992636771,
	1.51943252022827,
	1.5057615050118,
	1.49174152505741,
	1.47736696620736,
	1.46263194028281,
	1.44753026821644,
	1.43205546169654,
	1.41620070315761,
	1.39995882393024,
	1.38332228033666,
	1.36628312748775,
	1.34883299050186,
	1.33096303282328,
	1.31266392126902,
	1.2939257873736,
	1.27473818453185,
	1.25509004035606,
	1.23496960356404,
	1.21436438459343,
	1.19326108899162,
	1.17164554245173,
	1.14950260614655,
	1.12681608074222,
	1.10356859713828,
	1.07974149156128,
	1.05531466211154,
	1.03026640319184,
	1.0045732133883,
	0.978209571264714,
	0.951147672083024,
	0.923357116553767,
	0.894804540171926,
	0.865453168251795,
	0.835262277060074,
	0.804186534892375,
	0.772175187675088,
	0.739171040340956,
	0.705109165640325,
	0.669915242615786,
	0.633503381583527,
	0.595773220410311,
	0.55660595857116,
	0.515858793504701,
	0.473356862775726,
	0.42888111381683,
	0.382149146272707,
	0.332783047937946,
	0.280250838337874,
	0.223747088396741,
	0.161903864374734,
	0.0918401856348807,
	-8.50583000021389e-15
};

// Automatically generated lookup table of integrate(-2 * arctanh(e ^ (i * x)), x) from -0.1 to 0.0
// Generated by experiments/lookup_table.rb from mb-math, then copied and modified from mb-math to mb-sound
// experiments/lookup_table.rb "integrate(-2 * arctanh(e ^ (i * x)), x)" -0.1 0.0 21
static double SMALL_LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X[] = {
	0.399545439850515,
	0.384443605455943,
	0.369078095285853,
	0.353434288916255,
	0.337495840580432,
	0.321244354892652,
	0.304658975812297,
	0.287715857726498,
	0.270387473083062,
	0.252641688069872,
	0.234440500179617,
	0.215738267210309,
	0.196479142339785,
	0.176593212908555,
	0.155990402312772,
	0.134550231829575,
	0.112103181494428,
	0.0883926901258597,
	0.0629831458876054,
	0.0349573192633147,
	0
};

// Behaves like Ruby's % operator instead of fmod
// wraps X to be between 0 and Y
static double wrap(double x, double y)
{
	// this could instead be fmod(x, y) + y if x is negative
	return x - y * floor(x / y);
}

static ssize_t wrapsize(ssize_t x, ssize_t y)
{
	if (x >= 0 && x < y) {
		return x;
	}

	if (x < 0) {
		return x % y + y;
	}

	return x % y;
}

static double fetch_bounce(double table[], ssize_t len, ssize_t idx)
{
	if (idx >= 0 && idx < len) {
		return table[idx];
	}

	idx = wrapsize(idx, len * 2 - 2);

	if (idx >= len - 1) {
		idx = (2 * len - 2) - idx;
	}

	if (idx < 0 || idx >= len) {
		rb_raise(rb_eRuntimeError, "Bad index %zd", idx);
	}

	return table[idx];
}

// Handles expansion of quarter-wave lookup table (copied/modified from mb-math)
// Also see fetch_bounce from mb-math
static double get_lookup_i2aeixx(double table[], ssize_t len, ssize_t idx)
{
	double v = fetch_bounce(table, len, idx);

	if (idx >= len || idx <= -len) {
		v *= -1;
	}

	return v;
}

static double simple_catmull_rom(double p0, double p1, double p2, double p3, double blend)
{
	double t0 = 0.0;
	double t1 = 1.0;
	double t2 = 2.0;
	double t3 = 3.0;

	double d10 = t1 - t0;
	double d20 = t2 - t0;
	double d21 = t2 - t1;
	double d31 = t3 - t1;
	double d32 = t3 - t2;
	double t = blend * d21 + t1;
	double d0t = t0 - t;
	double d1t = t1 - t;
	double d2t = t2 - t;
	double d3t = t3 - t;

	double a1 = p0 * (d1t / d10) - p1 * (d0t / d10);
	double a2 = p1 * (d2t / d21) - p2 * (d1t / d21);
	double a3 = p2 * (d3t / d32) - p3 * (d2t / d32);
	double b1 = a1 * (d2t / d20) - a2 * (d0t / d20);
	double b2 = a2 * (d3t / d31) - a3 * (d1t / d31);

	return b1 * (d2t / d21) - b2 * (d1t / d21);
}

// Automatically generated (then manually modified) lookup-table-based
// approximation of integrate(-2 * arctanh(e ^ (i * x)), x)
// Uses 101 steps between -1.5707963267948966 and 0.0
// Generated by experiments/lookup_table.rb from mb-math with the help of Sage
static double complex lookup_integrate_2_arctanh_e_i_x_x(double x)
{
	double offset;
	double *table;
	size_t len;

	x = wrap(x + M_PI, 2.0 * M_PI) - M_PI;

	if (x > -0.09 && x < 0.09) {
		offset = (x + 0.1) * 20 / 0.1;
		table = SMALL_LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X;
		len = sizeof(SMALL_LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X) / sizeof(SMALL_LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X[0]);
	} else if (x > M_PI - 0.098) {
		offset = (x - M_PI + 0.1) * -20 / 0.1 + 40;
		table = SMALL_LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X;
		len = sizeof(SMALL_LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X) / sizeof(SMALL_LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X[0]);
	} else if (x < -M_PI + 0.098) {
		offset = (x + M_PI - 0.1) * -20 / 0.1;
		table = SMALL_LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X;
		len = sizeof(SMALL_LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X) / sizeof(SMALL_LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X[0]);
	} else {
		offset = (x + 1.5707963267948966) * 100 / 1.5707963267948966;
		table = LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X;
		len = sizeof(LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X) / sizeof(LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X[0]);
	}

	ssize_t idx = floor(offset);
	double frac = offset - idx;
	double real = simple_catmull_rom(
			get_lookup_i2aeixx(table, len, idx - 1),
			get_lookup_i2aeixx(table, len, idx),
			get_lookup_i2aeixx(table, len, idx + 1),
			get_lookup_i2aeixx(table, len, idx + 2),
			frac
			);

	// Triangle wave borrowed from mb-sound, back from mb-math
	double phi = wrap(x - M_PI_2, 2.0 * M_PI);
	double imag;
	if (phi < M_PI_2) {
		// Initial rise from 0..1 in 0..pi/2
		imag = phi * M_2_PI;
	} else if (phi < (1.5 * M_PI)) {
		// Fall from 1..-1 in pi/2..3pi/2
		imag = 2.0 - phi * M_2_PI;
	} else {
		// Final rise from -1..0 in 3pi/2..2pi
		imag = phi * M_2_PI - 4.0;
	}

	// 2.4674...*i == -pi*log(2) + I*dilog(2)
	return real - I * 2.46740110027234 * imag;
}

static double complex csc_int(double complex z)
{
	return -2.0 * conj(catanh(cexp(I * z))) + M_PI / (2.0 * I);
}

static double complex csc_int_int(double x)
{
	return lookup_integrate_2_arctanh_e_i_x_x(x);
}

static double complex cot_int(double complex z)
{
	return -M_2_PI * clog(cexp(I * z) + I) + I;
}

static double complex osc_sample(enum wave_types wave_type, double phi)
{
	double x;
	double complex z;
	double im;

	switch(wave_type) {
		case OSC_SINE:
			return sin(phi);

		case OSC_COMPLEX_SINE:
			return cexp(I * (phi - M_PI / 2));

		case OSC_TRIANGLE:
			if (phi < M_PI_2) {
				// Rise from 0..1 in 0..pi/2
				return phi * M_2_PI;
			} else if (phi < (M_PI + M_PI_2)) {
				// Fall from 1..-1 in pi/2..3pi/2
				return 2.0 - phi * M_2_PI;
			} else {
				// Rise from -1.0 in 3pi/2..2pi
				return phi * M_2_PI - 4.0;
			}

		case OSC_COMPLEX_TRIANGLE:
			// see lib/mb/sound/oscillator.rb
			// 2.4674...*i == -pi*log(2) + I*dilog(2)
			return csc_int_int(phi + M_PI_2) * I / 2.46740110027234;

		case OSC_SQUARE:
			// TODO: Normalize for RMS instead of peak?
			if (phi < M_PI) {
				return 1.0;
			} else {
				return -1.0;
			}

		case OSC_COMPLEX_SQUARE:
			z = 2.0 * conj(csc_int(phi)) * I / M_PI + 1.0;
			if (isinf(creal(z)) || isinf(cimag(z))) {
				z = 2.0 * conj(csc_int(phi + 0.0000001)) * I / M_PI + 1.0;
			}

			im = cimag(z);
			if (im > 3.8) {
				z = creal(z) + I * 3.8;
			} else if (im < -3.8) {
				z = creal(z) - I * 3.8;
			}

			return z;

		case OSC_RAMP:
			if (phi < M_PI) {
				// Initial rise from 0..1 in 0..pi
				return phi / M_PI;
			} else {
				// Final rise from -1..0 in pi..2pi
				return phi / M_PI - 2.0;
			}

		case OSC_COMPLEX_RAMP:
			z = cot_int(phi + M_PI_2) * I;

			im = cimag(z);
			if (im > 3.5) {
				z = creal(z) + I * 3.5;
			} else if (im < -3.5) {
				z = creal(z) - I * 3.5;
			}

			return z;

		case OSC_GAUSS:
			x = phi / M_PI;
			if (x < 1.0) {
				x = (sqrt(2.0 * log(1.6487212707 / (1.0 - x))) - 1) * 0.7071067811865476;
			} else {
				x = (1 - sqrt(2.0 * log(1.6487212707 / (x - 1.0)))) * 0.7071067811865476;
			}

			if (x < -3) {
				x = -3;
			} else if (x > 3) {
				x = 3;
			}

			return x;

		case OSC_PARABOLA:
			if (phi < M_PI) {
				x = 1.0 - phi * M_2_PI;
				return 1.0 - x * x;
			} else {
				x = phi * M_2_PI - 3.0;
				return x * x - 1.0;
			}

		default:
			return 0;
	}
}

static enum wave_types find_wave_type(ID wave_type)
{
	if (wave_type == sym_osc_sine) {
		return OSC_SINE;
	}
	if (wave_type == sym_osc_complex_sine) {
		return OSC_COMPLEX_SINE;
	}
	if (wave_type == sym_osc_triangle) {
		return OSC_TRIANGLE;
	}
	if (wave_type == sym_osc_complex_triangle) {
		return OSC_COMPLEX_TRIANGLE;
	}
	if (wave_type == sym_osc_square) {
		return OSC_SQUARE;
	}
	if (wave_type == sym_osc_complex_square) {
		return OSC_COMPLEX_SQUARE;
	}
	if (wave_type == sym_osc_ramp) {
		return OSC_RAMP;
	}
	if (wave_type == sym_osc_complex_ramp) {
		return OSC_COMPLEX_RAMP;
	}
	if (wave_type == sym_osc_gauss) {
		return OSC_GAUSS;
	}
	if (wave_type == sym_osc_parabola) {
		return OSC_PARABOLA;
	}

	rb_raise(rb_eRuntimeError, "Invalid wave type given: %"PRIsVALUE, wave_type);
}

static VALUE ruby_csc_int(VALUE self, VALUE z)
{
	double real, imag;

	if (!RB_TYPE_P(z, T_COMPLEX)) {
		real = NUM2DBL(z);
		imag = 0;
	} else {
		real = rb_complex_real(z);
		imag = rb_complex_imag(z);
	}

	complex double r = csc_int(real + I * imag);
	return rb_dbl_complex_new(creal(r), cimag(r));
}

static VALUE ruby_csc_int_int(VALUE self, VALUE z)
{
	double real, imag;

	if (!RB_TYPE_P(z, T_COMPLEX)) {
		real = NUM2DBL(z);
		imag = 0;
	} else {
		real = rb_complex_real(z);
		imag = rb_complex_imag(z);
	}

	complex double r = csc_int_int(real + I * imag);
	return rb_dbl_complex_new(creal(r), cimag(r));
}

static VALUE ruby_cot_int(VALUE self, VALUE z)
{
	double real, imag;

	if (!RB_TYPE_P(z, T_COMPLEX)) {
		real = NUM2DBL(z);
		imag = 0;
	} else {
		real = rb_complex_real(z);
		imag = rb_complex_imag(z);
	}

	complex double r = cot_int(real + I * imag);
	return rb_dbl_complex_new(creal(r), cimag(r));
}

static VALUE ruby_fmod(VALUE self, VALUE x, VALUE y)
{
	return rb_float_new(fmod(NUM2DBL(x), NUM2DBL(y)));
}

static VALUE ruby_remainder(VALUE self, VALUE x, VALUE y)
{
	return rb_float_new(remainder(NUM2DBL(x), NUM2DBL(y)));
}

static VALUE ruby_wrap(VALUE self, VALUE x, VALUE y)
{
	return rb_float_new(wrap(NUM2DBL(x), NUM2DBL(y)));
}

static VALUE ruby_wrapsize(VALUE self, VALUE x, VALUE y)
{
	return SSIZET2NUM(wrapsize(NUM2SSIZET(x), NUM2SSIZET(y)));
}

static VALUE ruby_idiv(VALUE self, VALUE x, VALUE y)
{
	return SSIZET2NUM(NUM2SSIZET(x) / NUM2SSIZET(y));
}

static VALUE ruby_imod(VALUE self, VALUE x, VALUE y)
{
	return SSIZET2NUM(NUM2SSIZET(x) % NUM2SSIZET(y));
}

static VALUE ruby_osc(VALUE self, VALUE wave_type, VALUE phi)
{
	enum wave_types wt = find_wave_type(SYM2ID(wave_type));

	double complex result = osc_sample(wt, NUM2DBL(phi));

	switch(wt) {
		case OSC_SINE:
		case OSC_SQUARE:
		case OSC_TRIANGLE:
		case OSC_RAMP:
		case OSC_GAUSS:
		case OSC_PARABOLA:
			return rb_float_new(creal(result));

		default:
			return rb_dbl_complex_new(creal(result), cimag(result));
	}
}

void Init_fast_sound(void)
{
	VALUE mb = rb_define_module("MB");
	VALUE fast_sound = rb_define_module_under(mb, "FastSound");

	sym_osc_sine = rb_intern("sine");
	sym_osc_complex_sine = rb_intern("complex_sine");
	sym_osc_triangle = rb_intern("triangle");
	sym_osc_complex_triangle = rb_intern("complex_triangle");
	sym_osc_square = rb_intern("square");
	sym_osc_complex_square = rb_intern("complex_square");
	sym_osc_ramp = rb_intern("ramp");
	sym_osc_complex_ramp = rb_intern("complex_ramp");
	sym_osc_gauss = rb_intern("gauss");
	sym_osc_parabola = rb_intern("parabola");

	rb_define_module_function(fast_sound, "osc", ruby_osc, 2);

	rb_define_module_function(fast_sound, "cot_int", ruby_cot_int, 1);
	rb_define_module_function(fast_sound, "csc_int", ruby_csc_int, 1);
	rb_define_module_function(fast_sound, "csc_int_int", ruby_csc_int_int, 1);

	rb_define_module_function(fast_sound, "fmod", ruby_fmod, 2);
	rb_define_module_function(fast_sound, "remainder", ruby_remainder, 2);
	rb_define_module_function(fast_sound, "wrap", ruby_wrap, 2);
	rb_define_module_function(fast_sound, "wrapsize", ruby_wrapsize, 2);
	rb_define_module_function(fast_sound, "idiv", ruby_idiv, 2);
	rb_define_module_function(fast_sound, "imod", ruby_imod, 2);
}
