#include <math.h>
#include <complex.h>

#include <ruby.h>

enum wave_types {
	OSC_SINE,
	OSC_COMPLEX_SINE,
	OSC_TRIANGLE,
	OSC_COMPLEX_TRIANGLE,
	OSC_SQUARE,
	OSC_COMPLEX_SQUARE,
	OSC_RAMP,
	OSC_COMPLEX_RAMP,
	OSC_GAUSS,
	OSC_PARABOLA,
};

static ID sym_osc_sine;
static ID sym_osc_complex_sine;
static ID sym_osc_triangle;
static ID sym_osc_complex_triangle;
static ID sym_osc_square;
static ID sym_osc_complex_square;
static ID sym_osc_ramp;
static ID sym_osc_complex_ramp;
static ID sym_osc_gauss;
static ID sym_osc_parabola;

// Automatically generated lookup table of integrate(-2 * arctanh(e ^ (i * x)), x) from -1.5707963267948966 to 0.0
// Generated by experiments/lookup_table.rb from mb-math, then copied and modified from m
// experiments/lookup_table.rb "integrate(-2 * arctanh(e ^ (i * x)), x)" -1.5707963267948966 0.0 101
static float LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X[] = {
	1.83193118835444,
	1.83180781576262,
	1.83143766754058,
	1.83082065231093,
	1.82995661765263,
	1.82884534991252,
	1.82748657394065,
	1.82587995274862,
	1.82402508708989,
	1.82192151496077,
	1.81956871102062,
	1.81696608592935,
	1.81411298560028,
	1.81100869036592,
	1.80765241405416,
	1.80404330297178,
	1.80018043479205,
	1.79606281734296,
	1.79168938729175,
	1.78705900872171,
	1.78217047159617,
	1.77702249010453,
	1.77161370088461,
	1.76594266111487,
	1.76000784646978,
	1.75380764893088,
	1.74734037444516,
	1.74060424042216,
	1.73359737305989,
	1.72631780448907,
	1.71876346972417,
	1.71093220340876,
	1.70282173634125,
	1.69442969176628,
	1.6857535814152,
	1.67679080127773,
	1.66753862708531,
	1.65799420948445,
	1.64815456887655,
	1.63801658989825,
	1.6275770155137,
	1.61683244068744,
	1.60577930560301,
	1.59441388838922,
	1.58273229731148,
	1.57073046238141,
	1.55840412633249,
	1.54574883490386,
	1.53275992636771,
	1.51943252022827,
	1.5057615050118,
	1.49174152505741,
	1.47736696620736,
	1.46263194028281,
	1.44753026821644,
	1.43205546169654,
	1.41620070315761,
	1.39995882393024,
	1.38332228033666,
	1.36628312748775,
	1.34883299050186,
	1.33096303282328,
	1.31266392126902,
	1.2939257873736,
	1.27473818453185,
	1.25509004035606,
	1.23496960356404,
	1.21436438459343,
	1.19326108899162,
	1.17164554245173,
	1.14950260614655,
	1.12681608074222,
	1.10356859713828,
	1.07974149156128,
	1.05531466211154,
	1.03026640319184,
	1.0045732133883,
	0.978209571264714,
	0.951147672083024,
	0.923357116553767,
	0.894804540171926,
	0.865453168251795,
	0.835262277060074,
	0.804186534892375,
	0.772175187675088,
	0.739171040340956,
	0.705109165640325,
	0.669915242615786,
	0.633503381583527,
	0.595773220410311,
	0.55660595857116,
	0.515858793504701,
	0.473356862775726,
	0.42888111381683,
	0.382149146272707,
	0.332783047937946,
	0.280250838337874,
	0.223747088396741,
	0.161903864374734,
	0.0918401856348807,
	-8.50583000021389e-15
};

// Automatically generated lookup table of integrate(-2 * arctanh(e ^ (i * x)), x) from -0.1 to 0.0
// Generated by experiments/lookup_table.rb from mb-math, then copied and modified from mb-math to mb-sound
// experiments/lookup_table.rb "integrate(-2 * arctanh(e ^ (i * x)), x)" -0.1 0.0 21
static float SMALL_LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X[] = {
	0.399545439850515,
	0.384443605455943,
	0.369078095285853,
	0.353434288916255,
	0.337495840580432,
	0.321244354892652,
	0.304658975812297,
	0.287715857726498,
	0.270387473083062,
	0.252641688069872,
	0.234440500179617,
	0.215738267210309,
	0.196479142339785,
	0.176593212908555,
	0.155990402312772,
	0.134550231829575,
	0.112103181494428,
	0.0883926901258597,
	0.0629831458876054,
	0.0349573192633147,
	0
};

// Handles expansion of quarter-wave lookup table (copied/modified from mb-math)
// Also see fetch_bounce from mb-math
float get_lookup_i2aeixx(float table[], ssize_t len, ssize_t idx)
{
	if (idx >= 0 && idx < len) {
		return table[idx];
	}

	idx %= len * 2 - 2;
	if (idx >= len - 1) {
		idx = (len - 2) - idx;
	}

	return table[idx];
}

static float simple_catmull_rom(float p0, float p1, float p2, float p3, float blend)
{
	float t0 = 0.0;
	float t1 = 1.0;
	float t2 = 2.0;
	float t3 = 3.0;

	float d10 = t1 - t0;
	float d20 = t2 - t0;
	float d21 = t2 - t1;
	float d31 = t3 - t1;
	float d32 = t3 - t2;
	float t = blend * d21 + t1;
	float d0t = t0 - t;
	float d1t = t1 - t;
	float d2t = t2 - t;
	float d3t = t3 - t;

	float a1 = p0 * (d1t / d10) - p1 * (d0t / d10);
	float a2 = p1 * (d2t / d21) - p2 * (d1t / d21);
	float a3 = p2 * (d3t / d32) - p3 * (d2t / d32);
	float b1 = a1 * (d2t / d20) - a2 * (d0t / d20);
	float b2 = a2 * (d3t / d31) - a3 * (d1t / d31);

	return b1 * (d2t / d21) - b2 * (d1t / d21);
}

// Automatically generated (then manually modified) lookup-table-based
// approximation of integrate(-2 * arctanh(e ^ (i * x)), x)
// Uses 101 steps between -1.5707963267948966 and 0.0
// Generated by experiments/lookup_table.rb from mb-math with the help of Sage
static float complex lookup_integrate_2_arctanh_e_i_x_x(float x)
{
	float offset;
	float *table;
	size_t len;

	x = fmodf(x + M_PI, 2.0 * M_PI) - M_PI;

	if (x > -0.09 && x < 0.09) {
		offset = (x + 0.1) * 20 / 0.1;
		table = SMALL_LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X;
		len = sizeof(SMALL_LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X) / sizeof(SMALL_LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X[0]);
	} else if (x > M_PI - 0.098) {
		offset = (x - M_PI + 0.1) * -20 / 0.1 + 40;
		table = SMALL_LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X;
		len = sizeof(SMALL_LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X) / sizeof(SMALL_LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X[0]);
	} else if (x < -M_PI + 0.098) {
		offset = (x + M_PI - 0.1) * -20 / 0.1;
		table = SMALL_LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X;
		len = sizeof(SMALL_LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X) / sizeof(SMALL_LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X[0]);
	} else {
		offset = (x + 1.5707963267948966) * 100 / 1.5707963267948966;
		table = LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X;
		len = sizeof(LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X) / sizeof(LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X[0]);
	}

	ssize_t idx = (ssize_t)lrint(offset);
	float frac = offset - idx;
	float real = simple_catmull_rom(
			get_lookup_i2aeixx(table, len, idx - 1),
			get_lookup_i2aeixx(table, len, idx),
			get_lookup_i2aeixx(table, len, idx + 1),
			get_lookup_i2aeixx(table, len, idx + 2),
			frac
			);

	// Triangle wave borrowed from mb-sound, back from mb-math
	float phi = fmodf(x - M_PI_2, 2.0 * M_PI);
	float imag;
	if (phi < M_PI_2) {
		// Initial rise from 0..1 in 0..pi/2
		imag = phi * M_2_PI; // M_2_PI is 2/pi
	} else if (phi < M_PI + M_PI_2) {
		// Fall from 1..-1 in pi/2..3pi/2
		imag = 2.0 - phi * M_2_PI;
	} else {
		// Final rise from -1..0 in 3pi/2..2pi
		imag = phi * M_2_PI - 4.0;
	}

	// 2.4674...*i == -pi*log(2) + I*dilog(2)
	return real - I * 2.46740110027234 * imag;
}

static float complex csc_int(float complex z)
{
	return -2.0f * conjf(catanhf(cexpf(I * z))) + M_PI_2 * I;
}

static float complex csc_int_int(float x)
{
	return lookup_integrate_2_arctanh_e_i_x_x(x);
}

static float complex cot_int(float complex z)
{
	return -M_2_PI * clogf(cexpf(I * z) + I) + I;
}

static float complex osc_sample(enum wave_types wave_type, float phi)
{
	float x;

	switch(wave_type) {
		case OSC_SINE:
			return sinf(phi);

		case OSC_COMPLEX_SINE:
			return cexpf(I * (phi - M_PI / 2));

		case OSC_TRIANGLE:
			if (phi < M_PI_2) {
				// Rise from 0..1 in 0..pi/2
				return phi * M_2_PI;
			} else if (phi < (M_PI + M_PI_2)) {
				// Fall from 1..-1 in pi/2..3pi/2
				return 2.0f - phi * M_2_PI;
			} else {
				// Rise from -1.0 in 3pi/2..2pi
				return phi * M_2_PI - 4.0f;
			}

		case OSC_COMPLEX_TRIANGLE:
			// see lib/mb/sound/oscillator.rb
			return csc_int_int(phi + M_PI_2) * I / 2.46740110027234;

		case OSC_SQUARE:
			// TODO: Normalize for RMS instead of peak?
			if (phi < M_PI) {
				return 1.0;
			} else {
				return -1.0;
			}

		case OSC_COMPLEX_SQUARE:
			return 2.0f * conjf(csc_int(phi)) * I / M_PI + 1.0f;

		case OSC_RAMP:
			if (phi < M_PI) {
				// Initial rise from 0..1 in 0..pi
				return phi / M_PI;
			} else {
				// Final rise from -1..0 in pi..2pi
				return phi / M_PI - 2.0f;
			}

		case OSC_COMPLEX_RAMP:
			return cot_int(phi * M_PI_2) * I;

		case OSC_GAUSS:
			x = phi / M_PI;
			if (x < 1.0) {
				return (sqrtf(2.0f * logf(1.6487212707 / (1.0 - x))) - 1) * 0.7071067811865476;
			} else {
				return (sqrtf(2.0f * logf(1.6487212707 / (x - 1.0))) + 1) * 0.7071067811865476;
			}

		case OSC_PARABOLA:
			if (phi < M_PI) {
				x = 1.0 - phi * M_2_PI;
				return 1.0 - x * x;
			} else {
				x = phi * M_2_PI - 3.0f;
				return x * x - 1.0;
			}

		default:
			return 0;
	}
}

static enum wave_types find_wave_type(ID wave_type)
{
	if (wave_type == sym_osc_sine) {
		return OSC_SINE;
	}
	if (wave_type == sym_osc_complex_sine) {
		return OSC_COMPLEX_SINE;
	}
	if (wave_type == sym_osc_triangle) {
		return OSC_TRIANGLE;
	}
	if (wave_type == sym_osc_complex_triangle) {
		return OSC_COMPLEX_TRIANGLE;
	}
	if (wave_type == sym_osc_square) {
		return OSC_SQUARE;
	}
	if (wave_type == sym_osc_complex_square) {
		return OSC_COMPLEX_SQUARE;
	}
	if (wave_type == sym_osc_ramp) {
		return OSC_RAMP;
	}
	if (wave_type == sym_osc_complex_ramp) {
		return OSC_COMPLEX_RAMP;
	}
	if (wave_type == sym_osc_gauss) {
		return OSC_GAUSS;
	}
	if (wave_type == sym_osc_parabola) {
		return OSC_PARABOLA;
	}

	rb_raise(rb_eRuntimeError, "Invalid wave type given: %"PRIsVALUE, wave_type);
}

VALUE ruby_osc(VALUE self, VALUE wave_type, VALUE phi)
{
	enum wave_types wt = find_wave_type(SYM2ID(wave_type));

	float complex result = osc_sample(wt, rb_float_value(phi));
	return rb_complex_new(crealf(result), cimagf(result));
}

void Init_fast_sound(void)
{
	VALUE mb = rb_define_module("MB");
	VALUE fast_sound = rb_define_module_under(mb, "FastSound");

	sym_osc_sine = rb_intern("sine");
	sym_osc_complex_sine = rb_intern("complex_sine");
	sym_osc_triangle = rb_intern("triangle");
	sym_osc_complex_triangle = rb_intern("complex_triangle");
	sym_osc_square = rb_intern("square");
	sym_osc_complex_square = rb_intern("complex_square");
	sym_osc_ramp = rb_intern("ramp");
	sym_osc_complex_ramp = rb_intern("complex_ramp");
	sym_osc_gauss = rb_intern("gauss");
	sym_osc_parabola = rb_intern("parabola");

	rb_define_module_function(fast_sound, "osc", ruby_osc, 2);
}
